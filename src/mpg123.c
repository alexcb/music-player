#include <ao/ao.h>
#include <mpg123.h>
#include <string.h>
#include <wiringPi.h>
#include <assert.h>

#include "httpget.h"
#include "lcd.h"

#define PIN_ROTARY_1 8
#define PIN_ROTARY_2 9
#define PIN_SWITCH 7

#define PIN_LCD_DC 4
#define PIN_LCD_RST 5
#define PIN_LED 1

#define LED_VALUE 256
#define CONTRAST 0xAA


#define BITS 8

struct httpdata hd;

char img_data[504] = {0x1, 0x0, 0x0, 0x0, 0x0, 0xa4, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0, 0x0, 0x0, 0x0, 0x4, 0x0, 0xfc, 0xf, 0x0, 0x0, 0x4, 0x80, 0x1f, 0x10, 0x0, 0xc, 0x4, 0xf0, 0xd, 0x10, 0x0, 0x38, 0x8, 0x18, 0x2, 0x10, 0x0, 0x60, 0x8, 0x8, 0x3, 0x10, 0x0, 0xc0, 0x9, 0xb6, 0x1, 0x10, 0x0, 0x0, 0x6, 0xd2, 0x0, 0x10, 0x0, 0x0, 0x0, 0x79, 0x0, 0x10, 0x0, 0x0, 0x83, 0x20, 0x0, 0x10, 0x0, 0xc0, 0x40, 0x30, 0x0, 0x10, 0x0, 0x20, 0x20, 0x1a, 0x0, 0x10, 0x0, 0x18, 0x30, 0x9, 0x0, 0x10, 0x0, 0x0, 0x10, 0xd, 0x0, 0x10, 0x0, 0x0, 0x88, 0x4, 0x0, 0x10, 0x0, 0x0, 0x48, 0x6, 0x0, 0x10, 0x0, 0x0, 0x4c, 0x3, 0x0, 0x10, 0x0, 0x0, 0x44, 0x1, 0x0, 0x10, 0x0, 0x0, 0x82, 0x1, 0x0, 0x10, 0x0, 0x0, 0x82, 0x0, 0x0, 0x10, 0x0, 0x0, 0x93, 0x0, 0x0, 0x10, 0x0, 0x0, 0x91, 0x0, 0x0, 0x10, 0x0, 0x0, 0x91, 0x0, 0x0, 0x10, 0x0, 0x0, 0xd1, 0xfc, 0xb, 0x10, 0x0, 0x80, 0x59, 0x40, 0x88, 0x13, 0x0, 0x80, 0x48, 0x40, 0x78, 0x10, 0x0, 0x80, 0x48, 0xc0, 0x1b, 0x10, 0x0, 0x80, 0x22, 0xfc, 0x8, 0x10, 0x0, 0x80, 0x22, 0x0, 0x8, 0x10, 0x0, 0x80, 0x22, 0x0, 0xa, 0x14, 0x0, 0xc0, 0x22, 0x0, 0x3, 0x13, 0x0, 0x40, 0x2a, 0xe0, 0xc1, 0x11, 0x0, 0x40, 0x2e, 0x78, 0x60, 0x11, 0x0, 0x40, 0x28, 0x46, 0x18, 0x11, 0x0, 0x60, 0x21, 0xfe, 0x38, 0x11, 0x0, 0x20, 0x31, 0x80, 0xc3, 0x13, 0x0, 0x20, 0x15, 0x0, 0x0, 0x16, 0x0, 0x20, 0x15, 0xfc, 0x0, 0x10, 0x0, 0x20, 0x15, 0xfc, 0x3, 0x10, 0x0, 0x30, 0x17, 0x64, 0xf0, 0x17, 0x0, 0x10, 0x14, 0x24, 0x10, 0x14, 0x0, 0x90, 0x10, 0x3c, 0x10, 0x14, 0x0, 0x50, 0x10, 0x0, 0x10, 0x14, 0x0, 0x50, 0x11, 0xfc, 0x17, 0x14, 0x0, 0x50, 0x11, 0x24, 0x30, 0x16, 0x0, 0xd0, 0x12, 0x24, 0x0, 0x10, 0x0, 0x90, 0x12, 0x24, 0xc0, 0x17, 0x0, 0x10, 0x16, 0x3c, 0x70, 0x14, 0x0, 0x30, 0x30, 0x0, 0x10, 0x14, 0x0, 0x20, 0x23, 0x38, 0x10, 0x14, 0x0, 0x40, 0x42, 0x60, 0x30, 0x14, 0x0, 0x80, 0xc0, 0xc0, 0x27, 0x13, 0x0, 0x0, 0x99, 0x30, 0xe0, 0x11, 0x0, 0x0, 0x33, 0x9, 0x0, 0x10, 0x0, 0x0, 0x36, 0x2, 0x0, 0x10, 0x0, 0x0, 0x4, 0xc, 0x0, 0x10, 0x0, 0x0, 0x8c, 0x18, 0x0, 0x10, 0x0, 0x0, 0x90, 0x33, 0x0, 0x10, 0x0, 0x0, 0x20, 0xc1, 0x0, 0x10, 0x0, 0x0, 0x20, 0x80, 0x0, 0x10, 0x0, 0x0, 0x40, 0x98, 0x0, 0x10, 0x0, 0x0, 0x83, 0x31, 0x1, 0x10, 0x0, 0x0, 0x1, 0x2, 0x3, 0x10, 0x0, 0xc0, 0x0, 0x1c, 0x1e, 0x10, 0x0, 0x20, 0x3, 0xf0, 0x70, 0x10, 0x0, 0x10, 0x1, 0x80, 0x81, 0x13, 0x0, 0x18, 0x5, 0x0, 0x7, 0xe, 0x0, 0x88, 0x4, 0x0, 0xfc, 0xf, 0x0, 0x80, 0x2, 0x0, 0x0, 0x0, 0x0, 0x40, 0x2, 0x0, 0x0, 0x0, 0x0, 0x40, 0x2, 0x0, 0x0, 0x0, 0x0, 0x40, 0x2, 0x0, 0x0, 0x0, 0x0, 0x40, 0x2, 0x0, 0x0, 0x0, 0x0, 0x40, 0x6, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0};


void drawLCD()
{
	//# White backlight
	//CONTRAST = 0xaa
	//
	//ROWS = 6
	//COLUMNS = 14
	//PIXELS_PER_ROW = 6
	//ON = 1
	//OFF = 0
	//
	//#gpio's :
	//DC   = 4 # gpio pin 16 = wiringpi no. 4 (BCM 23)
	//RST  = 5 # gpio pin 18 = wiringpi no. 5 (BCM 24)
	//LED  = 1 # gpio pin 12 = wiringpi no. 1 (BCM 18)
	//
	//# SPI connection
	//SCE  = 10 # gpio pin 24 = wiringpi no. 10 (CE0 BCM 8) 
	//SCLK = 14 # gpio pin 23 = wiringpi no. 14 (SCLK BCM 11)
	//DIN  = 12 # gpio pin 19 = wiringpi no. 12 (MOSI BCM 10)

	pinMode( PIN_LCD_DC, OUTPUT );
	pinMode( PIN_LCD_RST, OUTPUT );


    //# if LED == 1 set pin mode to PWM else set it to OUT
	assert( PIN_LED == 1 );
	pinMode( PIN_LED, 2);
	pwmWrite( PIN_LED, 0);

	//# Toggle RST low to reset.
	digitalWrite( PIN_LCD_RST, 0 );
	delay(100);
	digitalWrite( PIN_LCD_RST, 1 );

	LCDState lcd_state;

	init_lcd( &lcd_state, 0, PIN_LCD_DC, PIN_LCD_RST, PIN_LED );
	set_contrast( &lcd_state, CONTRAST );
	draw_image( &lcd_state, (uint8_t *)img_data );

	//int fd = wiringPiSPISetup(0, 4000000);

	//// set contrast
	//assert( 0x80 <= CONTRAST );
	//assert( CONTRAST < 0xFF );
	//char contrastBuf[] = { 0x21, 0x14, CONTRAST, 0x20, 0x0c };
	//digitalWrite(PIN_LCD_DC, 0);
	//write(fd, contrastBuf, 5);
	//	
	////set LED backlight
	//assert( 0 <= LED_VALUE );
	//assert( LED_VALUE < 1023 );
	//pwmWrite( PIN_LED, LED_VALUE );

	//// enable vertical addressing mode
	////digitalWrite(PIN_LCD_DC, 0);
	////char ctrlBuf3[] = { 0x22 };
	////write(fd, ctrlBuf3, 1);

	////goto (0, 0)
	//digitalWrite(PIN_LCD_DC, 0);
	//char ctrlBuf[] = { 0+128, 0+64 };
	//write(fd, ctrlBuf, 2);
	//
	//// enable vertical addressing mode
	//digitalWrite(PIN_LCD_DC, 0);
	//char ctrlBuf3[] = { 0x22 };
	//write(fd, ctrlBuf3, 1);
	//
	////  display
	////goto (0, 0)
	//digitalWrite(PIN_LCD_DC, 0);
	//char ctrlBuf2[] = { 0+128, 0+64 };
	//write(fd, ctrlBuf2, 2);
	//
	//digitalWrite(PIN_LCD_DC, 1);
	//write(fd, img_data, 504);

}

int main(int argc, char *argv[])
{
	mpg123_handle *mh;
	unsigned char *buffer;
	size_t buffer_size;
	size_t done;
	int err;

	int driver;
	ao_device *dev;

	ao_sample_format format;
	int channels, encoding;
	long rate;

	if( wiringPiSetup() == -1 ) {
		printf("failed setting up wiringPi\n");
		return 1;
	}


	if(argc < 2) {
		printf("setting up lcd\n");
		drawLCD();
		exit(0);
	}

	/* initializations */
	ao_initialize();
	driver = ao_default_driver_id();
	mpg123_init();
	mh = mpg123_new(NULL, &err);
	buffer_size = mpg123_outblock(mh);
	buffer = (unsigned char*) malloc(buffer_size * sizeof(unsigned char));

	httpdata_reset(&hd);

	if( strstr(argv[1], "http://") ) {
		int fd = http_open(argv[1], &hd);
		printf("setting icy %ld\n", hd.icy_interval);
		if(MPG123_OK != mpg123_param(mh, MPG123_ICY_INTERVAL, hd.icy_interval, 0)) {
			printf("unable to set icy interval\n");
			return 1;
		}
		if(mpg123_open_fd(mh, fd) != MPG123_OK) {
			printf("error\n");
			return 1;
		}
	} else {
		/* open the file and get the decoding format */
		mpg123_open(mh, argv[1]);
	}
	mpg123_getformat(mh, &rate, &channels, &encoding);

	/* set the output format and open the output device */
	format.bits = mpg123_encsize(encoding) * BITS;
	format.rate = rate;
	format.channels = channels;
	format.byte_format = AO_FMT_NATIVE;
	format.matrix = 0;
	dev = ao_open_live(driver, &format, NULL);

	mpg123_id3v1 *v1;
	mpg123_id3v2 *v2;
	char *icy_meta;

	/* decode and play */
	while (mpg123_read(mh, buffer, buffer_size, &done) == MPG123_OK) {

		int meta = mpg123_meta_check(mh);
		if( meta & MPG123_NEW_ID3 ) {
			if( mpg123_id3(mh, &v1, &v2) == MPG123_OK ) {
				printf("got meta\n");
				if( v1 != NULL ) {
					printf("title: %s\n", v1->title);
					printf("artist: %s\n", v1->artist);
				}
				if( v2 != NULL ) {
					printf("title: %s\n", v2->title->p);
					printf("artist: %s\n", v2->artist->p);
				}
			}
		}
		if( meta & MPG123_NEW_ICY ) {
			if( mpg123_icy(mh, &icy_meta) == MPG123_OK ) {
				printf("got ICY: %s\n", icy_meta);

			}
		}

		ao_play(dev, (char *) buffer, done);
	}

	/* clean up */
	free(buffer);
	ao_close(dev);
	mpg123_close(mh);
	mpg123_delete(mh);
	mpg123_exit();
	ao_shutdown();

	return 0;
}
